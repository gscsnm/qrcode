<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>æ‰¹é‡å›¾ä¹¦æ‰«ç ï¼ˆè®¡æ•°ç‰ˆï¼‰</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;padding:14px;color:#111}
  h1{font-size:1.1rem;margin-bottom:6px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  .btn{padding:8px 12px;border-radius:6px;border:1px solid #ccc;background:#f7f7f7;cursor:pointer}
  .btn.primary{background:#0b84ff;color:#fff;border-color:#0b84ff}
  #video, #reader {width:100%;max-width:480px;background:#000;margin:0 auto;border-radius:6px}
  table{width:100%;border-collapse:collapse;margin-top:12px}
  th,td{border:1px solid #eee;padding:8px;font-size:0.9rem;text-align:left}
  input,select{padding:8px;width:100%;box-sizing:border-box}
  .small{font-size:0.85rem;color:#666}
  .flex{display:flex;gap:8px}
  .pill{padding:6px 8px;border-radius:999px;border:1px solid #ddd;background:#fafafa}
</style>
</head>
<body>
  <h1>ğŸ“š æ‰¹é‡æ‰«ç å¹¶è®¡æ•°ï¼ˆZXing + html5-qrcode åŒå¼•æ“ï¼‰</h1>
  <div class="small">è¯·åœ¨ HTTPS é¡µé¢ï¼ˆGitHub Pages / Netlifyï¼‰æ‰“å¼€ä»¥å…è®¸æ‘„åƒå¤´è®¿é—®ã€‚åç½®æ‘„åƒå¤´è¯†åˆ«æ›´ç¨³å®šã€‚</div>

  <div class="controls">
    <button id="startBtn" class="btn primary">å¼€å§‹æ‰«ç </button>
    <button id="stopBtn" class="btn">åœæ­¢æ‰«ç </button>
    <button id="undoBtn" class="btn">æ’¤é”€ä¸Šä¸€æ¬¡</button>
    <button id="clearBtn" class="btn">æ¸…ç©ºå…¨éƒ¨</button>
    <label class="pill"><input id="dupAllow" type="checkbox" checked> å…è®¸å¿«é€Ÿé‡å¤è®¡æ•°</label>
    <label class="pill"><input id="autoFetch" type="checkbox" checked> è‡ªåŠ¨æŠ“ OpenLibrary ä¿¡æ¯</label>
  </div>

  <div style="max-width:480px;margin:0 auto">
    <video id="video" playsinline></video>
    <div id="reader" style="display:none"></div>
  </div>

  <div style="margin-top:12px;max-width:680px">
    <div class="flex">
      <input id="manualInput" placeholder="æ‰‹åŠ¨æ¡ç æˆ– ISBNï¼Œå›è½¦æ·»åŠ " />
      <button id="manualAdd" class="btn">æ·»åŠ </button>
    </div>
    <div class="small" style="margin-top:6px">å¦‚æœè®¾å¤‡è¿ç»­å¸§å¤šæ¬¡è¯†åˆ«åŒä¸€ä¸ªæ¡ç ï¼Œä¼šåœ¨ <strong>å…è®¸å¿«é€Ÿé‡å¤è®¡æ•°</strong> å–æ¶ˆæ—¶é¿å…é‡å¤è®¡æ•°ï¼ˆé»˜è®¤å…è®¸ï¼‰ã€‚</div>
  </div>

  <table id="tb" style="margin-top:14px">
    <thead>
      <tr><th>#</th><th>æ¡ç </th><th>æ•°é‡</th><th>é¦–æ¬¡æ‰«æ</th><th>æœ€è¿‘æ‰«æ</th><th>æ“ä½œ</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap">
    <button id="exportCsv" class="btn">å¯¼å‡ºæ±‡æ€» CSV</button>
    <button id="exportEvents" class="btn">å¯¼å‡ºäº‹ä»¶ CSVï¼ˆæ¯æ¬¡æ‰«ç ï¼‰</button>
    <button id="downloadTxt" class="btn">ä¸‹è½½æ¡ç  TXTï¼ˆæ¯è¡Œä¸€æ¡ï¼‰</button>
  </div>

<script src="https://unpkg.com/@zxing/browser@latest"></script>
<script src="https://unpkg.com/html5-qrcode/minified/html5-qrcode.min.js"></script>
<script>
/* æ•°æ®ç»“æ„ï¼š
  counts: Map barcode -> { count, first, last }
  events: [ {barcode, time} ] ç”¨äºå¯¼å‡ºäº‹ä»¶æ—¥å¿—å’Œæ’¤é”€
*/
const counts = new Map();
const events = []; // [{barcode, time}]
const lastScanAt = new Map(); // barcode -> timestamp for short debounce
const DEBOUNCE_MS = 800; // åŒä¸€æ¡ç åœ¨æ­¤æ—¶é—´å†…é‡å¤è¯†åˆ«è§†ä¸ºåŒä¸€æ¬¡ï¼ˆå¯é€šè¿‡å…è®¸å¿«é€Ÿé‡å¤è®¡æ•°å¤é€‰æ¡†æ”¹å˜è¡Œä¸ºï¼‰
let allowQuickDup = true;

const videoElem = document.getElementById('video');
const readerElem = document.getElementById('reader');
const tbody = document.querySelector('#tb tbody');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const undoBtn = document.getElementById('undoBtn');
const clearBtn = document.getElementById('clearBtn');
const manualInput = document.getElementById('manualInput');
const manualAdd = document.getElementById('manualAdd');
const exportCsv = document.getElementById('exportCsv');
const exportEvents = document.getElementById('exportEvents');
const downloadTxt = document.getElementById('downloadTxt');
const dupAllowCheckbox = document.getElementById('dupAllow');
const autoFetchCheckbox = document.getElementById('autoFetch');

dupAllowCheckbox.onchange = ()=> { allowQuickDup = dupAllowCheckbox.checked; };

manualInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') manualAdd.click(); });
manualAdd.onclick = ()=>{ const v = manualInput.value.trim(); if(v) handleScanned(v); manualInput.value=''; manualInput.focus(); };

startBtn.onclick = startScanner;
stopBtn.onclick = stopScanner;
undoBtn.onclick = undoLast;
clearBtn.onclick = clearAll;
exportCsv.onclick = downloadSummaryCSV;
exportEvents.onclick = downloadEventsCSV;
downloadTxt.onclick = downloadTxtFile;

function nowISO(){ return new Date().toISOString(); }

function handleScanned(raw) {
  const code = String(raw).replace(/\s+/g,'');
  const t = Date.now();
  if(!allowQuickDup){
    const last = lastScanAt.get(code) || 0;
    if(t - last < DEBOUNCE_MS) return; // å¿½ç•¥è¿‡å¿«é‡å¤
  }
  lastScanAt.set(code, t);
  // æ›´æ–° counts
  const rec = counts.get(code);
  if(rec){
    rec.count += 1;
    rec.last = nowISO();
  } else {
    counts.set(code, { count: 1, first: nowISO(), last: nowISO() });
  }
  // push event for history
  events.push({ barcode: code, time: nowISO() });
  // render
  renderTable();
  // optional: è‡ªåŠ¨æŠ“å–ä¹¦ç±å…ƒæ•°æ®ï¼ˆå¯ä»¥åç»­æ‰©å±•ï¼‰
  if(autoFetchCheckbox.checked){
    // ä»…å½“ä»£ç åƒ ISBN æ—¶æ‰å°è¯•ï¼ˆç®€å•åˆ¤æ–­ï¼‰
    const isIsbn = /^\d{10}$|^\d{13}$/.test(code.replace(/[^0-9Xx]/g,''));
    if(isIsbn){
      // å¯ä»¥åœ¨è¿™é‡Œè°ƒç”¨ OpenLibrary å¹¶æŠŠç»“æœä¿å­˜åˆ° a separate map if needed
      // æš‚æ—¶ä¸æ’å…¥ UIï¼Œåªæ¼”ç¤ºå¯æ‰©å±•ç‚¹
      fetch(`https://openlibrary.org/api/books?bibkeys=ISBN:${code}&format=json&jscmd=data`)
        .then(r=>r.json()).then(js=>{
          const key = `ISBN:${code}`;
          if(js && js[key]){
            // ä½ å¯ä»¥æŠŠä¹¦å/ä½œè€…ä¿å­˜åˆ° counts çš„é¢å¤–å­—æ®µï¼Œä¾‹å¦‚ rec.title = ...
            const info = js[key];
            const rec2 = counts.get(code);
            rec2.title = info.title || '';
            rec2.authors = (info.authors||[]).map(a=>a.name).join(', ');
            renderTable(); // æ›´æ–°æ˜¾ç¤ºï¼ˆå¦‚æœä½ é€‰æ‹©åœ¨è¡¨æ ¼ä¸­æ˜¾ç¤ºï¼‰
          }
        }).catch(()=>{});
    }
  }
}

function renderTable(){
  tbody.innerHTML = '';
  let i = 0;
  for(const [barcode, rec] of counts.entries()){
    i++;
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${i}</td>
      <td>${escapeHtml(barcode)}</td>
      <td>
        <button class="btn" data-action="dec" data-code="${barcode}">-</button>
        &nbsp;<span>${rec.count}</span>&nbsp;
        <button class="btn" data-action="inc" data-code="${barcode}">+</button>
      </td>
      <td>${rec.first || ''}</td>
      <td>${rec.last || ''}</td>
      <td>
        <button class="btn" data-action="remove" data-code="${barcode}">åˆ é™¤</button>
      </td>
    `;
    tbody.appendChild(tr);
  }
  // attach listeners
  tbody.querySelectorAll('button[data-action]').forEach(b=>{
    const action = b.dataset.action;
    const code = b.dataset.code;
    b.onclick = ()=> {
      if(action === 'inc'){ increase(code,1); }
      else if(action === 'dec'){ increase(code,-1); }
      else if(action === 'remove'){ counts.delete(code); renderTable(); }
    };
  });
}

function increase(code, delta){
  const rec = counts.get(code);
  if(!rec) return;
  rec.count += delta;
  if(rec.count <= 0) {
    counts.delete(code);
  } else {
    rec.last = nowISO();
  }
  // push event if positive increment by scan simulated
  if(delta>0){ events.push({barcode: code, time: nowISO()}); }
  renderTable();
}

function undoLast(){
  const ev = events.pop();
  if(!ev){ alert('æ²¡æœ‰å¯æ’¤é”€çš„æ‰«ç '); return; }
  const code = ev.barcode;
  const rec = counts.get(code);
  if(rec){
    rec.count -= 1;
    if(rec.count <= 0) counts.delete(code);
    else rec.last = nowISO();
  }
  renderTable();
}

function clearAll(){
  if(!confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰è®°å½•å—ï¼Ÿ')) return;
  counts.clear(); events.length = 0; renderTable();
}

// CSV å¯¼å‡ºï¼š summary å’Œ events
function downloadSummaryCSV(){
  const header = ['barcode','count','first_seen','last_seen'];
  const rows = [];
  for(const [barcode, rec] of counts.entries()){
    rows.push([barcode, String(rec.count), rec.first || '', rec.last || '']);
  }
  let csv = header.join(',') + '\\n';
  rows.forEach(r => { csv += r.map(csvEscape).join(',') + '\\n'; });
  downloadBlob(csv, `books_summary_${(new Date()).toISOString().slice(0,10)}.csv`, 'text/csv;charset=utf-8;');
}

function downloadEventsCSV(){
  const header = ['barcode','time'];
  let csv = header.join(',') + '\\n';
  events.forEach(e => { csv += [e.barcode, e.time].map(csvEscape).join(',') + '\\n'; });
  downloadBlob(csv, `books_events_${(new Date()).toISOString().slice(0,10)}.csv`, 'text/csv;charset=utf-8;');
}

function downloadTxtFile(){
  // æ¯è¡Œ barcode,count
  let txt = '';
  for(const [barcode, rec] of counts.entries()){
    txt += `${barcode},${rec.count}\\n`;
  }
  downloadBlob(txt, `books_${(new Date()).toISOString().slice(0,10)}.txt`, 'text/plain');
}

function csvEscape(v){
  if(v===null||v===undefined) return '""';
  const s = String(v).replaceAll('"','""');
  return \`"\${s}"\`;
}
function downloadBlob(content, filename, type){
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}
function escapeHtml(s){ if(!s) return ''; return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('\"','&quot;'); }

/* Scanner logic: prefer @zxing/browser; fallback to html5-qrcode */
let codeReader = null;
let html5Qr = null;
let scanning = false;

async function startScanner(){
  if(scanning) return;
  scanning = true;
  // try zxing
  try {
    const ZXing = window.ZXing;
    if(!ZXing || !ZXing.BrowserMultiFormatReader) throw new Error('ZXing not available');
    codeReader = new ZXing.BrowserMultiFormatReader();
    const devices = await ZXing.BrowserCodeReader.listVideoInputDevices();
    let deviceId = devices.length ? devices[devices.length-1].deviceId : undefined; // prefer last (rear)
    await codeReader.decodeFromVideoDevice(deviceId, 'video', (result, err) => {
      if(result && result.getText){
        handleScanned(result.getText());
      }
      // ignore NotFoundException errors
    });
    console.log('ZXing started');
  } catch(e){
    console.warn('ZXing failed, fallback to html5-qrcode', e);
    // Fallback: html5-qrcode
    document.getElementById('video').style.display = 'none';
    readerElem.style.display = 'block';
    try {
      html5Qr = new Html5Qrcode("reader");
      const cams = await Html5Qrcode.getCameras();
      const camId = cams && cams.length ? cams[0].id : null;
      if(!camId) throw new Error('no camera for html5-qrcode');
      await html5Qr.start(camId, { fps: 10, qrbox: 250 },
        (decoded) => { handleScanned(decoded); },
        (err) => {}
      );
      console.log('html5-qrcode started');
    } catch(err){
      console.error('html5-qrcode start failed', err);
      alert('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼š' + err);
      scanning = false;
    }
  }
}

function stopScanner(){
  scanning = false;
  if(codeReader){
    try{ codeReader.reset(); }catch(e){}
    codeReader = null;
  }
  if(html5Qr){
    html5Qr.stop().catch(()=>{}); html5Qr = null;
  }
  document.getElementById('video').style.display = '';
  readerElem.style.display = 'none';
}

window.addEventListener('beforeunload', ()=>{ stopScanner(); });

</script>
</body>
</html>
